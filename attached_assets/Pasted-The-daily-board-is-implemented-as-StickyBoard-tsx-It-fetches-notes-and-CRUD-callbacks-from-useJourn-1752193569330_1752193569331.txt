The daily board is implemented as StickyBoard.tsx. It fetches notes and CRUD callbacks from useJournal and wraps the board in NoteContextProvider so child shells can update or delete notes. The code maps legacyNotes to StickyNoteShell components and renders a grid overlay when grid snapping is enabled:

26  export const StickyBoard: React.FC = () => {
27    const {
28      legacyNotes,
29      updateNote,
30      deleteNote,
31      gridSnap,
32      setGridSnap
33    } = useJournal();
...
46    const noteComponents = useMemo(() => legacyNotes.map(note => {
47      const NoteComponent = noteRegistry[note.type];
...
55        <NoteErrorBoundary
56          key={note.id}
57          noteId={note.id}
58          onDelete={deleteNote}
59        >
60          <StickyNoteShell
61            id={note.id}
62            position={note.position}
63            color={getNoteTint(note.type)}
64            onLocalDragEnd={onLocalDragEnd}
65          >
66            <NoteComponent
67              content={note.content}
68              onChange={(content: any) => updateNote(note.id, { content })}

StickyBoard exposes a floating toggle for grid snapping and renders all note components within the board container:

81          <div className="sticky-board relative w-full h-full overflow-hidden bg-gray-50">
82            {/* Grid overlay when grid snap is enabled */}
83            {gridSnap && (
...
98            {/* Grid snap toggle */}
99            <button
100              onClick={() => setGridSnap(!gridSnap)}
101              className="fixed bottom-8 right-8 w-12 h-12 bg-white/80 backdrop-blur-sm rounded-full shadow-lg hover:shadow-xl transition-all duration-200 flex items-center justify-center"
102              title={gridSnap ? 'Disable grid snap' : 'Enable grid snap'}

Each note shell handles pointer events and applies grid snapping inside the move handler. StickyNoteShell uses requestAnimationFrame to update style transforms and commits a debounced position update when dragging ends:

72    const handlePointerDown = useCallback((e: React.PointerEvent) => {
...
90      setIsDragging(true);
91      touchIdentifierRef.current = e.pointerId;
92    }, [position]);

95    const moveNote = useCallback((e: React.PointerEvent) => {
96      if (!isDragging || e.pointerId !== touchIdentifierRef.current) return;
...
108      // Apply grid snap BEFORE updating live position to prevent single-frame mismatch
109      if (gridSnapEnabled) {
110        rawX = snapToGrid(rawX);
111        rawY = snapToGrid(rawY);
112      }
...
151      const finalPosition: NotePosition = {
152        ...position,
153        x: optimisticPosRef.current.x,
154        y: optimisticPosRef.current.y
155      };

157      // Use debounced update to prevent rapid successive calls
158      debouncedUpdatePosition(finalPosition);

The board-level context (noteContext.tsx) buffers updates in a map and flushes them after 100 ms. This prevents multiple network calls per drag event:

41    // Batched updates with debounce
42    const updateNote = useCallback((id: string, updates: Partial<NoteData>): void => {
43      updateQueueRef.current.set(id, {
44        ...updateQueueRef.current.get(id),
45        ...updates,
46      });

48      if (updateTimeoutRef.current) {
49        clearTimeout(updateTimeoutRef.current);
50      }

52      updateTimeoutRef.current = setTimeout(() => {
53        const updates = Array.from(updateQueueRef.current.entries());
54        updateQueueRef.current.clear();

56        updates.forEach(([noteId, noteUpdates]) => {
57          onUpdate(noteId, noteUpdates);
58        });
59      }, 100); // Debounce time
60    }, [onUpdate]);

Legacy Bridge
JournalContext converts existing content blocks to note data using blocksToNotes and converts note updates back via noteToBlockPatch:

    52  export const blockToNote = (block: ContentBlockData): StickyNoteData => {
    53    return {
    54      id: block.id,
    55      type: blockTypeToNoteType(block.type),
    56      content: block.content,
    57      position: block.position,
    58      createdAt: block.createdAt,
    59      updatedAt: block.updatedAt,
    60    };
    61  };
...
     8  export const noteToBlockPatch = (
     9    note: Partial<StickyNoteData>,
    10    existingBlock?: ContentBlockData
    11  ): Partial<ContentBlockData> => {
    12    // Only update position if it's provided in the note update

Within journal-context.tsx, these helpers bridge the new board layer with the legacy API:

  const legacyNotes = currentEntry?.contentBlocks
    ? blocksToNotes(currentEntry.contentBlocks)
    : [];

  const updateNote = (id: string, data: Partial<StickyNoteData>) => {
    const existingBlock = currentEntry?.contentBlocks.find((b) => b.id === id);
    const blockUpdates = noteToBlockPatch(data, existingBlock);
    updateContentBlock(id, blockUpdates);
  };

Collaboration Hook
useCollaboration sets up a Yjs document with WebRTC and IndexedDB persistence. It also throttles updates after local drags to avoid echoing:

 3  import { useEffect, useCallback, useRef } from 'react';
 4  import * as Y from 'yjs';
 5  import { WebrtcProvider } from 'y-webrtc';
...
37  const ROOM_NAME = 'photo-journal-board';
...
107        // Listen for changes with CRDT echo throttling
108        notesMap.observe((event: YjsChangeEvent) => {
109          const now = Date.now();
110          if (event.origin && event.origin.clientID === doc.clientID &&
111              now - lastLocalDragRef.current < CRDT_ECHO_THROTTLE) {
112            return;
113          }

However, StickyBoard currently renders notes from useJournal instead of reading from the Yjs store. Only onLocalDragEnd is consumed from the collaboration hook, so the real-time sync path is not yet the source of truth. The attached design spec confirms the intention for the board to own state and Yjs sync:

24    "architectural_rules": [
25      "StickyBoard = state + Yjs sync + selection + creation toolbar",
26      "StickyNoteShell = drag, resize, grip, chrome (timestamp, delete…) — no content logic",
27      "noteTypes/* = render & edit their own content only",
28      "Data flow: Board↔Shell (meta/position) • Shell↔Content (content)",
29      "snapToGrid(20 px) called inside move handler when user pref `gridSnap=true`"

Assessment and Refactoring Considerations
Current state vs. spec – The existing board delegates note state to JournalContext. This is simpler but bypasses the intended Yjs store and collaboration features. Refactoring to follow the “Board → Shell → Content” split would mean letting StickyBoard manage note state via useBoardStore and Yjs, while JournalContext only loads and persists.

Grid snapping – Implemented via snapToGrid.ts with a default grid size of 20 px. Shells snap positions while dragging.

Update pathway – Note updates are buffered for 100 ms. Depending on network latency and how often notes are dragged, you may still generate many HTTP PATCH requests, whereas the spec aimed for Yjs to handle these locally and sync just the final result.

Legacy compatibility – The mapping layer (blockToNote and noteToBlockPatch) allows gradual migration. But as long as StickyBoard consumes legacyNotes, drag performance is tied to the server.

Given the disparity between the implemented board and the intended spec, an engineer considering a refactor should evaluate migrating StickyBoard to fully use useCollaboration and the Zustand useBoardStore. This would reduce network chatter and allow richer collaboration features as outlined in the spec.