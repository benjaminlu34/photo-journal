Below is a focused critique of the current drag code and a set of incremental refactors that will eliminate the three pain-points you named:

excess API chatter 2. React re-render cascades 3. per-mousemove DOM cost.

I keep every change small enough to land in sequence; try the first two and you’ll feel the UI snap to 60 fps before you even touch the server.

1 · Collapse to one pointer-handling system
Problem
react-dnd’s hook fires on every motion and you add your own global mousemove listeners, so each pointer event is processed twice. The extra bookkeeping (isDragging, dragMonitor, localPosition) multiplies React state churn. content-block

Fix (≈20 LOC)
Keep react-dnd only for cross-block drop detection or remove it entirely and handle everything with native Pointer Events.

For pure dragging you can ditch useDrag / useDrop and call onPointerDown/Move/Up on the block.

React-dnd can still wrap the workspace for re-ordering or “drop onto another day” later, but don’t double-register per-block listeners.

tsx
Copy
Edit
// NEW: pointer-down starts drag, no react-dnd on the block
const onPointerDown = (e: React.PointerEvent) => {
  if (e.button !== 0) return;           // ignore right-click
  e.currentTarget.setPointerCapture(e.pointerId);
  startDrag(e);
};
Benefit: ~30 % less JS work per frame, simpler mental model.

2 · Lift render-time math off the React path
Problem
Every pixel of movement calls setLocalPosition inside debouncedUpdatePosition, thereby re-rendering the block up to 60× per second (mouse → state → React → DOM). content-block

Fix (≈25 LOC)
Replace the localPosition state with a useRef that holds the live numbers.

Mutate the block’s inline style directly inside a requestAnimationFrame loop; call setState once, on drop, so React stays in sync.

tsx
Copy
Edit
const live = useRef(block.position);          // not a state
const styleRef = useRef<HTMLDivElement>(null);

const moveRAF = useRef<number>();

const updateVisual = (x: number, y: number) => {
  live.current.x = x; live.current.y = y;
  if (!moveRAF.current) {
    moveRAF.current = requestAnimationFrame(() => {
      styleRef.current!.style.transform =
        `translate3d(${live.current.x}px,${live.current.y}px,0) rotate(${live.current.rotation}deg)`;
      moveRAF.current = 0;                  // ready for next frame
    });
  }
};
Benefit: DOM updates are GPU-accelerated (translate3d) and immunised from React’s scheduling.

3 · Cache expensive geometry once per drag
Problem
querySelector('[data-workspace="true"]') + getBoundingClientRect runs on every mousemove. That forces a layout pass, murdering smoothness. content-block

Fix (≈6 LOC)
Capture workspaceRect at drag start and reuse it until pointer-up.

tsx
Copy
Edit
const workspaceRect = document
  .querySelector('[data-workspace="true"]')!
  .getBoundingClientRect();
// …store in closure, no further DOM reads this drag
Benefit: layout thrash disappears; 5-10 ms saved per move on mid-range laptops.

4 · Push one CRDT patch per drag, not 3-5 PATCH calls
Problem
You debounce to 150 ms, but a typical 1-second drag still yields 6-7 HTTP calls + an immediate one on mouseup. Each call triggers a Prisma query → SWR/React Query invalidation → full workspace re-render.

Fix (backend-agnostic)
Persist through Yjs
The drag writes to the Yjs doc locally; Y-WebSocket syncs at idle or visibilitychange.
One message covers the full move—it’s just the final position Map value.

If you must stay REST for now
Hold the final live.current numbers at pointerup and do a single PATCH /block/:id.
The earlier frames never touch the network.

tsx
Copy
Edit
const endDrag = () => {
  // only now call updateBlockPosition(live.current)
};
Benefit: 80–90 % drop in API volume, no cascading query invalidations.

5 · Side-effects & cleanup
Memory leaks – keep the single requestAnimationFrame id; cancelAnimationFrame on unmount.

Z-index – set via CSS class, not inline, so Tailwind’s GPU clip/raster can cache.

Keyboard parity – you can still listen to keydown and mutate live.current → updateVisual, the a11y layer is unchanged.

6 · Migration checklist (safe order)
Remove per-block useDrag → confirm nothing breaks.

Introduce liveRef + updateVisual → verify silky moves, no React warnings.

Swap left/top for translate3d in CSS.

Change handleMouseUp to fire one updateBlockPosition.

Add Yjs persistence or single REST call.

Delete now-unused localPosition, isDragging etc. from state.

The above steps are orthogonal—you can ship each behind a short-lived feature flag to derisk.

Quick visual confirmation tip
Run performance.mark('drag') on pointer-down and performance.measure() on pointer-up. You should see:

Metric	Before	After
Frames missed @ 60 fps	~35 %	< 5 %
PATCH requests / drag	3-7	1
React renders / block	20-40	0–1

Once those numbers drop, the “sticky” feeling goes away and the canvas will feel native-app fast even on mobile.