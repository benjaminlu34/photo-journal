üîç What actually broke (and when) in the refactor
Refactor step	What changed	Why it looked fine	Why it now hammers /api/content-blocks
Step C ‚Üí Step D<br/>- ‚Äúblocks ‚Üí notes shim‚Äù	JournalContext was introduced as a bridge: it exposes legacyNotes (blocks ‚Üí notes) and an updateNote helper that immediately calls updateContentBlock ‚Üí network PATCHÔªø journal-context	Local UI still rendered; every call to updateNote merely queued a React-Query mutation, so no errors were obvious at first	The old StickyNoteShell (copied from firm #1) fires updateNote(...) on every mouse-move while you drag StickyNoteShell. In the original Firm #1 stack that only mutated an in-memory Yjs doc (cheap). After the bridge was wired, every pixel ‚Üí updateContentBlock ‚Üí HTTP PATCH Ôªø‚Äî thus the flood
Step E<br/>- ‚ÄúBoard now uses legacyNotes‚Äù	StickyBoard stopped using the fast useCollaboration hook and instead renders legacyNotes from JournalContext, wiring its shell to that same updateNote bridge StickyBoard	UI still draws, grid-snap works, so the change slipped through code-review	The moment you drag, you‚Äôre inside the REST-backed pathway described above, not the local Yjs path

In other words, nothing is wrong with Firm #1‚Äôs components; the regression appeared the moment we re-routed the shell‚Äôs high-frequency drag events through a network-backed mutation without buffering.

How to verify the diagnosis
Comment-out the body of JournalContext.updateNote so it only does a console.log and does not call updateContentBlock.

Dragging a note becomes buttery-smooth again (proof the shell is fine).

Swap back to useCollaboration in StickyBoard (file shows the earlier import still commented) and bypass JournalContext.

Smooth drag confirms the bridge layer is the culprit.

Watch the Network tab: every pixel ‚Üí PATCH while using the current bridge; zero requests when you do either test above.

Where to fix (without ‚Äúband-aids‚Äù, just restoring intended architecture)
File	Line	Action
StickyNoteShell.tsx StickyNoteShell	updateNote(note.id, { position: ‚Ä¶ }) inside handleMouseMove	Keep this local (Yjs) only. Persist on handleMouseUp (one call) or through Yjs awareness-sync batching.
JournalContext.tsx journal-context	updateNote implementation	Either (a) debounced / throttled, or (b) move it to run only when a note‚Äôs updatedAt is changed after drag end.
StickyBoard.tsx StickyBoard	Source of truth for notes	During the transition you can keep both providers:<br/>useCollaboration for high-frequency local ops ‚ü∂ Yjs<br/>JournalContext only for low-frequency save / load.

Once that separation is restored, the huge request burst disappears and you‚Äôre back to Firm #1‚Äôs smooth UX, while still marching toward the final split-component architecture.

TL;DR
The refactor went wrong precisely when we bridged Firm #1‚Äôs mouse-move-heavy note shell to a network mutation that was never meant to be called per pixel. Re-introduce local (Yjs) state for drag-time updates and call the REST patch once when the drag ends (or buffer via debounce) and the lag will vanish.

For reference here is the useCollaboration file:

import { useEffect, useState, useCallback } from 'react';
import * as Y from 'yjs';
import { WebsocketProvider } from 'y-websocket';
import { IndexeddbPersistence } from 'y-indexeddb';
import { StickyNoteData } from '@/components/StickyNote/StickyNote';

export interface UserPresence {
  id: string;
  name: string;
  color: string;
  cursor?: { x: number; y: number };
}

export const useCollaboration = (spaceId: string) => {
  const [ydoc] = useState(() => new Y.Doc());
  const [provider, setProvider] = useState<WebsocketProvider | null>(null);
  const [indexeddbProvider] = useState(() => new IndexeddbPersistence(spaceId, ydoc));
  const [notes, setNotes] = useState<StickyNoteData[]>([]);
  const [users, setUsers] = useState<Map<string, UserPresence>>(new Map());
  const [currentUser] = useState<UserPresence>({
    id: Math.random().toString(36).substr(2, 9),
    name: `User ${Math.floor(Math.random() * 1000)}`,
    color: `hsl(${Math.floor(Math.random() * 360)}, 70%, 50%)`,
  });

  useEffect(() => {
    // Create WebSocket provider (fallback to local if no server)
    const wsProvider = new WebsocketProvider(
      'ws://localhost:1234', 
      spaceId, 
      ydoc,
      { 
        connect: false // Don't auto-connect, we'll handle it manually
      }
    );

    // Try to connect, but don't fail if server is not available
    try {
      wsProvider.connect();
    } catch (error) {
      console.log('WebSocket server not available, working offline');
    }

    setProvider(wsProvider);

    // Get or create the notes array in the shared document
    const yNotes = ydoc.getArray<StickyNoteData>('notes');

    // Subscribe to changes
    const updateNotes = () => {
      setNotes(yNotes.toArray());
    };

    yNotes.observe(updateNotes);
    updateNotes(); // Initial load

    // Handle presence awareness
    const awareness = wsProvider.awareness;
    awareness.setLocalStateField('user', currentUser);

    const updateUsers = () => {
      const states = awareness.getStates();
      const userMap = new Map<string, UserPresence>();
      
      states.forEach((state, clientId) => {
        if (state.user && clientId !== awareness.clientID) {
          userMap.set(clientId.toString(), state.user);
        }
      });
      
      setUsers(userMap);
    };

    awareness.on('change', updateUsers);
    updateUsers();

    return () => {
      yNotes.unobserve(updateNotes);
      awareness.off('change', updateUsers);
      wsProvider.destroy();
    };
  }, [spaceId, ydoc, currentUser]);

  const addNote = useCallback((note: StickyNoteData) => {
    const yNotes = ydoc.getArray<StickyNoteData>('notes');
    yNotes.push([note]);
  }, [ydoc]);

  const updateNote = useCallback((noteId: string, updates: Partial<StickyNoteData>) => {
    const yNotes = ydoc.getArray<StickyNoteData>('notes');
    const noteIndex = yNotes.toArray().findIndex(note => note.id === noteId);
    
    if (noteIndex >= 0) {
      const currentNote = yNotes.get(noteIndex);
      const updatedNote = { ...currentNote, ...updates, updatedAt: new Date() };
      yNotes.delete(noteIndex, 1);
      yNotes.insert(noteIndex, [updatedNote]);
    }
  }, [ydoc]);

  const deleteNote = useCallback((noteId: string) => {
    const yNotes = ydoc.getArray<StickyNoteData>('notes');
    const noteIndex = yNotes.toArray().findIndex(note => note.id === noteId);
    
    if (noteIndex >= 0) {
      yNotes.delete(noteIndex, 1);
    }
  }, [ydoc]);

  const updateCursor = useCallback((x: number, y: number) => {
    if (provider?.awareness) {
      provider.awareness.setLocalStateField('user', {
        ...currentUser,
        cursor: { x, y }
      });
    }
  }, [provider, currentUser]);

  return {
    notes,
    users,
    currentUser,
    addNote,
    updateNote,
    deleteNote,
    updateCursor,
    isConnected: provider?.wsconnected ?? false,
  };
};
